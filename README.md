# è‡ªå‹•æ¥åƒåœ¾åƒåœ¾æ¡¶ï¼ˆSmart Moving Trash Canï¼‰

---

## 1. é—œæ–¼å°ˆæ¡ˆ

æœ¬å°ˆæ¡ˆç‚ºä¸€å°**è‡ªå‹•æ¥åƒåœ¾åƒåœ¾æ¡¶**ï¼Œé€éæ¨¹è“æ´¾èˆ‡æ”å½±æ©Ÿé€²è¡Œå½±åƒè¾¨è­˜ï¼Œç•¶ç³»çµ±åµæ¸¬åˆ°ä½¿ç”¨è€…æ‰‹ä¸­æŒæœ‰åƒåœ¾æ™‚ï¼Œåƒåœ¾æ¡¶æœƒè‡ªå‹•ç§»å‹•åˆ°ä½¿ç”¨è€…é™„è¿‘ï¼Œè®“ä½¿ç”¨è€…å¯ä»¥æ›´æ–¹ä¾¿åœ°ä¸Ÿåƒåœ¾ã€‚  
>#### æœ¬å°ˆæ¡ˆä»¥ä¹’ä¹“çƒä»£æ›¿åƒåœ¾åšæ¨¡æ“¬

## 2. å°ˆæ¡ˆç·£ç”±

æ—¥å¸¸ç”Ÿæ´»ä¸­å¸¸å¸¸é‡åˆ°æ‰‹ä¸Šæœ‰åƒåœ¾ã€ä½†åƒåœ¾æ¡¶è·é›¢å¤ªé æˆ–ä¸æ–¹ä¾¿é è¿‘çš„æƒ…æ³ã€‚  
æœ¬å°ˆæ¡ˆå¸Œæœ›é€éæ©Ÿå™¨äººèˆ‡å½±åƒè¾¨è­˜æŠ€è¡“ï¼Œè®“åƒåœ¾æ¡¶èƒ½ä¸»å‹•é è¿‘äººï¼Œæå‡ç”Ÿæ´»ä¾¿åˆ©æ€§ã€‚

---

## 3. å°ˆæ¡ˆæ§‹æƒ³

æŒ‰ç…§ä»¥ä¸‹æ­¥é©Ÿï¼Œé€æ­¥å®Œæˆæ™ºæ…§åƒåœ¾æ¡¶çš„é››å‹ï¼š

1. å»ºç«‹å¯ç§»å‹•çš„è»Šè¼›åº•ç›¤  
2. ä½¿ç”¨ç›´æµé¦¬é”èˆ‡é¦¬é”é©…å‹•æ¿æ§åˆ¶å‰é€²ã€å¾Œé€€èˆ‡è½‰å‘  
3. å®‰è£æ”å½±æ©Ÿæ“·å–å³æ™‚å½±åƒ  
4. é€éå½±åƒè™•ç†è¾¨è­˜åƒåœ¾æˆ–ç‰¹å®šé¡è‰²ç‰©é«”  
5. æ ¹æ“šç‰©é«”ä½ç½®ï¼Œè‡ªå‹•æ§åˆ¶åƒåœ¾æ¡¶ç§»å‹•é è¿‘ä½¿ç”¨è€…  

---

## 4. æ‰€éœ€ææ–™

1. è»Šè¼›åº•ç›¤ï¼‹è¼ªçµ„  
2. 24V ç›´æµæ¸›é€Ÿé¦¬é” Ã— 2  
3. BTS7960 é¦¬é”æ§åˆ¶æ¿ Ã— 2  
4. é›»æ± æ¨¡çµ„ï¼ˆä¾›æ‡‰é¦¬é”é›»æºï¼‰  
5. Raspberry Pi 4  
6. Raspberry Pi 4 ä¸æ–·é›» 5V ä¾›é›»ç³»çµ±(æˆ–æ˜¯è¡Œå‹•é›»æº)  
7. æ¨¹è“æ´¾ OV5647 æ”å½±é¡é ­æ¨¡çµ„  
   - 500 è¬åƒç´   
   - 160 åº¦å»£è§’  
   - å¯èª¿ç„¦ï¼ˆé­šçœ¼ï¼‰  
8. åƒåœ¾æ¡¶æˆ–å®¹å™¨ï¼ˆå®‰è£æ–¼è»Šé«”ä¸Šï¼‰  
9. æœé‚¦ç·šã€å›ºå®šææ–™ï¼ˆèºçµ²ã€æ”¯æ¶ç­‰ï¼‰

---

## 5. å¯¦é«”ç…§ç‰‡ã€å„è£ç½®ç´°ç¯€ç…§ç‰‡

æ•´é«”å¤–è§€ç…§ç‰‡ï¼š  
![æ•´é«”å¤–è§€](image/è»Šè¼›.jpeg)

è»Šè¼›åº•ç›¤è£ç½®ç´°ç¯€ï¼š  
![åº•ç›¤ç´°ç¯€1](image/åº•ç›¤1.jpeg)
![åº•ç›¤ç´°ç¯€2](image/åº•ç›¤2.jpeg)

æ”å½±æ©Ÿå®‰è£ä½ç½®ï¼š  
![æ”å½±æ©Ÿå®‰è£](image/æ”å½±æ©Ÿ.jpeg)

---

## 6. é›»è·¯é…ç½®

æ¨¹è“æ´¾ GPIO æ¥ç·šç¤ºæ„åœ–ï¼š  
![GPIO æ¥ç·šåœ–](image/é›»è·¯åœ–.png)

---

## 7. ç¨‹å¼è¨­è¨ˆã€ç’°å¢ƒè¨­ç½®

### è¨­ç½®ï¼š

- ä½œæ¥­ç³»çµ±ï¼šRaspberry Pi OSï¼ˆRaspberry Pi OS TrixieåŸºæ–¼ Debian 13ï¼‰  
- ä½¿ç”¨ Python é€²è¡Œé–‹ç™¼  
- å½±åƒè™•ç†ä½¿ç”¨ OpenCV  
- æ”å½±æ©Ÿæ¨¡çµ„ä½¿ç”¨ Picamera2  

### ç’°å¢ƒè¨­ç½®ï¼ˆç„¡è™›æ“¬ç’°å¢ƒï¼‰:
> æ³¨æ„ï¼š`libcamera` åœ¨è™›æ“¬ç’°å¢ƒä¸­å¯èƒ½æŠ“ä¸åˆ°è·¯å¾‘ï¼Œå»ºè­°ç›´æ¥åœ¨ç³»çµ± Python ä¸‹å®‰è£ã€‚
> å¦‚æœæ¸¬è©¦å¾Œæ²’å•é¡Œä¹Ÿå¯åœ¨è™›æ“¬ç’°å¢ƒä¸­é€²è¡Œï¼Œæœ¬å°ˆæ¡ˆæœªåœ¨è™›æ“¬ç’°å¢ƒä¸­é€²è¡Œ

1.**æ›´æ–°ç³»çµ±å¥—ä»¶**
```python  
sudo apt update
sudo apt upgrade -y
```

2.**å®‰è£ Python èˆ‡å¿…è¦å¥—ä»¶**
```python
sudo apt install python3-pip python3-dev python3-numpy -y
sudo apt install libatlas-base-dev libjpeg-dev libtiff-dev libjasper-dev libpng-dev -y
sudo apt install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev -y
sudo apt install libxvidcore-dev libx264-dev -y
sudo apt install libgtk-3-dev -y
sudo apt install libatlas-base-dev gfortran -y
```
3.**å®‰è£ OpenCV**
```python
pip3 install opencv-python
```
4.**å®‰è£ Raspberry Pi å°ˆç”¨å¥—ä»¶**
```python
pip3 install RPi.GPIO
sudo apt install python3-picamera2 -y
sudo apt install libcamera-apps -y
```
5.**å…¶ä»–å¿…è¦å¥—ä»¶**
```python
pip3 install numpy
```
---
### ç¨‹å¼è¨­è¨ˆï¼š

#### 1.åœ¨é–‹å§‹ä¹‹å‰
>### æœ¬å°ˆæ¡ˆåˆ¤å®šåƒåœ¾çš„æ–¹å¼æ˜¯ä»¥è‰²å½©è’™ç‰ˆè¾¨è­˜ï¼Œå¦‚è¦ä½¿ç”¨AIæ¨¡å‹åˆ¤å®šå¯å¿½ç•¥1.2.3éƒ¨åˆ†
>### å»ºè­°ä¾ç…§æ­¥é©Ÿå–®å…ƒæ¸¬è©¦å¾Œå†åŸ·è¡Œä¸»ç¨‹å¼

---

#### 2.HSV è‰²å½©è’™ç‰ˆèªªæ˜

åœ¨åƒåœ¾æ¡¶è¿½è¹¤å°ˆæ¡ˆä¸­ï¼Œæˆ‘å€‘ä½¿ç”¨ HSV è‰²å½©è’™ç‰ˆä¾†è¾¨è­˜æ‰‹ä¸Šåƒåœ¾çš„é¡è‰²ï¼Œä»¥ä¸‹èªªæ˜å…¶åŸç†èˆ‡ç”¨é€”ã€‚

---

#### (1) HSV è‰²å½©ç©ºé–“æ˜¯ä»€éº¼ï¼Ÿ

HSV æ˜¯ä¸€ç¨®ç”¨ä¾†æè¿°é¡è‰²çš„æ–¹å¼ï¼Œç”±ä¸‰å€‹éƒ¨åˆ†çµ„æˆï¼š

| é …ç›® | èªªæ˜ |
|------|------|
| **H (Hueï¼Œè‰²ç›¸)** | é¡è‰²æœ¬èº«ï¼Œä¾‹å¦‚ç´…ã€ç¶ ã€è—ã€‚æ•¸å€¼é€šå¸¸ 0~179ï¼ˆOpenCV ä½¿ç”¨ç¯„åœ 0~179ï¼‰ |
| **S (Saturationï¼Œé£½å’Œåº¦)** | é¡è‰²çš„ç´”åº¦ï¼Œå€¼è¶Šé«˜é¡è‰²è¶Šé®®è±”ï¼Œå€¼ä½å‰‡åç° |
| **V (Valueï¼Œæ˜åº¦/äº®åº¦)** | é¡è‰²çš„äº®åº¦æˆ–å¼·åº¦ï¼Œå€¼è¶Šé«˜é¡è‰²è¶Šäº®ï¼Œå€¼ä½å‰‡åé»‘ |

**HSV èˆ‡ RGB çš„å·®ç•°ï¼š**

- **RGB** è¡¨ç¤ºç´…ã€ç¶ ã€è—ä¸‰ç¨®å…‰çš„å¼·åº¦çµ„åˆï¼Œå—å…‰ç·šå½±éŸ¿è¼ƒå¤§ã€‚
- **HSV** åˆ†é›¢äº†é¡è‰² (H) èˆ‡äº®åº¦ (V)ï¼Œå°å…‰ç·šè®ŠåŒ–ä¸æ•æ„Ÿï¼Œæ›´ç¬¦åˆäººçœ¼å°é¡è‰²çš„æ„ŸçŸ¥ã€‚

---

#### (2) ç¨‹å¼ä¸­ HSV è’™ç‰ˆçš„ç”¨é€”

ç¨‹å¼ç‰‡æ®µï¼š

```python
H_MIN = 100; H_MAX = 127
S_MIN = 175; S_MAX = 255
V_MIN = 110; V_MAX = 255
LOWER_COLOR = np.array([H_MIN, S_MIN, V_MIN])
UPPER_COLOR = np.array([H_MAX, S_MAX, V_MAX])

hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
mask = cv2.inRange(hsv, LOWER_COLOR, UPPER_COLOR)
```
åŠŸèƒ½èªªæ˜ï¼š

è½‰æ›è‰²å½©ç©ºé–“
å°‡æ”å½±æ©Ÿæ•æ‰çš„ BGR å½±åƒè½‰æ›æˆ HSVï¼š
```python
hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
```

å»ºç«‹é¡è‰²è’™ç‰ˆ
```python
mask = cv2.inRange(hsv, LOWER_COLOR, UPPER_COLOR)
```
- å°‡åœ¨æŒ‡å®š HSV ç¯„åœå…§çš„åƒç´ è¨­ç‚ºç™½è‰² (255)ï¼Œç¯„åœå¤–è¨­ç‚ºé»‘è‰² (0)ã€‚
- ç™½è‰²éƒ¨åˆ†å³ç›®æ¨™é¡è‰²ï¼ˆä¾‹å¦‚è—è‰²ä¹’ä¹“çƒ / æ¨¡æ“¬åƒåœ¾ï¼‰ã€‚

å¾ŒçºŒè™•ç†

- ä½¿ç”¨ cv2.findContours æ‰¾åˆ°ç™½è‰²å€åŸŸã€‚
- è¨ˆç®—ä¸­å¿ƒåº§æ¨™ (X, Y)ã€‚
- æ§åˆ¶é¦¬é”å‘ç›®æ¨™ç§»å‹•ã€‚

#### (3) HSV è’™ç‰ˆç¤ºæ„åœ–
- åŸå§‹å½±åƒï¼šæ‰‹ä¸Šæ‹¿è‘—åƒåœ¾
- HSV è’™ç‰ˆå¾Œå½±åƒï¼šç›®æ¨™é¡¯ç¤ºç‚ºç™½è‰²å€åŸŸ

![HSV è’™ç‰ˆç¤ºæ„åœ–](image/hsvè‰²å½©æ¸¬è©¦ç¯„ä¾‹åœ–.png)

---

#### 3.ç›®æ¨™ç‰©é¡è‰²æ¸¬è©¦hsv_color_test.py/hsv_color_test2.py
#### HSV é¡è‰²ç¯„åœæ¸¬è©¦ç¨‹å¼èªªæ˜

#### (1) åŠŸèƒ½
é€™å€‹ç¨‹å¼å¯ä»¥ï¼š
- ä½¿ç”¨ Picamera2 å–å¾—å³æ™‚å½±åƒ
- å°‡ BGR å½±åƒè½‰æ›ç‚º HSV è‰²å½©ç©ºé–“
- åˆ©ç”¨æ»‘æ¢å³æ™‚èª¿æ•´ HSV ç¯„åœ
- é¡¯ç¤ºç›®æ¨™ç‰©é«”çš„è’™ç‰ˆèˆ‡è¿½è¹¤è¼ªå»“
- å¹«åŠ©è¨­å®šä¸»ç¨‹å¼çš„ `LOWER_COLOR` èˆ‡ `UPPER_COLOR` åƒæ•¸

#### (2) åŸ·è¡Œæ–¹å¼
1. å°‡ç¨‹å¼ä¸Šå‚³è‡³æ¨¹è“æ´¾
2. ä½¿ç”¨ä»¥ä¸‹æŒ‡ä»¤åŸ·è¡Œï¼š
```python
python3 hsv_color_test.py
```
#### (3) èª¿æ•´ HSV æ»‘æ¢

æ»‘æ¢åŠŸèƒ½å¦‚ä¸‹ï¼š

| æ»‘æ¢   | åŠŸèƒ½       |
|--------|------------|
| H_MIN  | è‰²ç›¸ä¸‹é™   |
| H_MAX  | è‰²ç›¸ä¸Šé™   |
| S_MIN  | é£½å’Œåº¦ä¸‹é™ |
| S_MAX  | é£½å’Œåº¦ä¸Šé™ |
| V_MIN  | æ˜åº¦ä¸‹é™   |
| V_MAX  | æ˜åº¦ä¸Šé™   |

æ“ä½œæ–¹å¼ï¼š
- èª¿æ•´æ»‘æ¢ï¼Œè§€å¯Ÿ `Mask` è¦–çª—ä¸­çš„ç™½è‰²å€åŸŸæ˜¯å¦å°æ‡‰ç›®æ¨™é¡è‰²ã€‚
- ç¢ºèªå¾Œè¨˜ä¸‹å°æ‡‰æ•¸å€¼ï¼Œä½œç‚ºè¿½è¹¤ç¨‹å¼çš„çš„é è¨­æ•¸å€¼

#### (4) é¡¯ç¤ºèˆ‡è¼ªå»“

- ç¨‹å¼æœƒè‡ªå‹•å°‹æ‰¾è’™ç‰ˆä¸­çš„æœ€å¤§è¼ªå»“ã€‚
- ä»¥ç¶ è‰²åœ“åœˆæ¨™è¨˜ç›®æ¨™ç‰©é«”ä¸­å¿ƒã€‚
- å¯è¦–åŒ–è¿½è¹¤æ•ˆæœï¼Œæ–¹ä¾¿å¾®èª¿ HSV ç¯„åœã€‚

#### (5) çµæŸç¨‹å¼

- æŒ‰ä¸‹ `q` éµæˆ–ä½¿ç”¨ Ctrl+C çµæŸç¨‹å¼ã€‚
- ç¨‹å¼æœƒè‡ªå‹•é‡‹æ”¾æ”å½±æ©Ÿèˆ‡é—œé–‰è¦–çª—ã€‚

>#### ç¢ºå®šæ•¸å€¼å¾Œå¯åœ¨hsv_color_test2ä¸­æ¸¬è©¦æ•¸å€¼æ­£ç¢ºæ€§

---
#### 4.é¦¬é”æ¸¬è©¦ motor_test.py

æœ¬ç¨‹å¼ç‚º **å–®é¡†ç›´æµé¦¬é” PWM æ§åˆ¶æ¸¬è©¦ç¨‹å¼**ï¼Œ  
ä½¿ç”¨ Raspberry Pi GPIO æ­é… PWM è¨Šè™Ÿï¼Œæ¸¬è©¦é¦¬é”çš„ï¼š

- æ­£è½‰ï¼ˆForwardï¼‰
- åè½‰ï¼ˆBackwardï¼‰
- åœæ­¢ï¼ˆStopï¼‰
- ä¸åŒè½‰é€Ÿï¼ˆDuty Cycleï¼‰
#### PWMè…³ä½å®šç¾©
```python
RPWM = 13  # æ­£è½‰ PWM
LPWM = 19  # åè½‰ PWM
```
#### é¦¬é”æ§åˆ¶å‡½å¼
#### (1)åœæ­¢é¦¬é”ï¼ˆStopï¼‰
```python
def stop():
    pwmR.ChangeDutyCycle(0)
    pwmL.ChangeDutyCycle(0)
    print("STOP")

```
#### (2)æ­£è½‰ï¼ˆForwardï¼‰
```python
def forward(speed):
    pwmR.ChangeDutyCycle(speed)
    pwmL.ChangeDutyCycle(0)

```
#### (3)åè½‰ï¼ˆBackwardï¼‰
```python
def backward(speed):
    pwmR.ChangeDutyCycle(0)
    pwmL.ChangeDutyCycle(speed)

```

---
#### 5.å·¦å³è¼ªèª¤å·®æ¸¬è©¦ motor_test2.py
#### PWMè…³ä½å®šç¾©
```python
# å·¦è¼ªé¦¬é”
L_RPWM_PIN = 18 
L_LPWM_PIN = 12  

# å³è¼ªé¦¬é”
R_RPWM_PIN = 13  
R_LPWM_PIN = 19  
```
####å³è¼ªæ ¡æ­£å› å­ (åˆå§‹å€¼ 1.0)
```python
# è‹¥è»Šå­å¾€å³åï¼Œä»£è¡¨å·¦è¼ªå¤ªå¿«ï¼Œæ‡‰èª¿é™å·¦è¼ªæˆ–æé«˜å³è¼ªã€‚
# é€™è£¡æˆ‘å€‘å°‡ä»¥å·¦è¼ª (1.0) ç‚ºåŸºæº–ï¼Œèª¿æ•´å³è¼ªçš„é€Ÿåº¦ã€‚
CALIBRATION_FACTOR_R = 0.6 
```
####ä¸»è¦æ ¡æ­£å‡½å¼
```python
def move_forward_straight(base_speed, factor_R):
    """
    è‡ªèµ°è»Šå‰é€²ï¼Œæ‡‰ç”¨å³è¼ªæ ¡æ­£å› å­ã€‚
    å·¦è¼ªé€Ÿåº¦ = base_speed
    å³è¼ªé€Ÿåº¦ = base_speed * factor_R
    """
    speed_L = base_speed
    speed_R = int(base_speed * factor_R)
    
    # ç¢ºä¿é€Ÿåº¦åœ¨ 0-100 ç¯„åœ
    speed_L = max(0, min(100, speed_L))
    speed_R = max(0, min(100, speed_R))

    # å·¦è¼ªå‰é€² (RPWM)
    pwm_L_L.ChangeDutyCycle(0)
    pwm_L_R.ChangeDutyCycle(speed_L)
    
    # å³è¼ªå‰é€² (RPWM)
    pwm_R_L.ChangeDutyCycle(0)
    pwm_R_R.ChangeDutyCycle(speed_R)
    
    print(f"L_Speed: {speed_L}% | R_Speed: {speed_R}%")
```


#### 6.ä¸»ç¨‹å¼ app.py
ç’°å¢ƒè¨­ç½®
```python
import cv2
import numpy as np
import time
import sys
import RPi.GPIO as GPIO
from picamera2 import Picamera2
from libcamera import controls 
```
GPIO PIN å®šç¾©èˆ‡è¨­å®š
```python
L_FWD_PIN = 18
L_BWD_PIN = 12
R_FWD_PIN = 13
R_BWD_PIN = 19

PWM_FREQUENCY = 1000
MAX_SPEED_DUTY = 100

pwm_L_fwd, pwm_L_bwd, pwm_R_fwd, pwm_R_bwd = None, None, None, None
```
æ ¡æº–èˆ‡è¿½è¹¤åƒæ•¸
```python
#å½±åƒå¤§å°
FRAME_WIDTH = 640
FRAME_HEIGHT = 480

# å·²ç¢ºèªHSV
H_MIN = 100; H_MAX = 130; S_MIN = 140; S_MAX = 255; V_MIN = 125; V_MAX = 255
LOWER_COLOR = np.array([H_MIN, S_MIN, V_MIN])
UPPER_COLOR = np.array([H_MAX, S_MAX, V_MAX])

FLIP_CODE = 0 # å½±åƒç¿»è½‰ä¿®æ­£

# P-Control åƒæ•¸
CENTER_X = FRAME_WIDTH // 2
CENTER_Y = FRAME_HEIGHT // 2 # Y è»¸ç›®æ¨™: é–å®šåœ¨ç•«é¢æ­£ä¸­å¿ƒ 240 åƒç´ è™•

X_TOLERANCE = 60         # å¢åŠ  X è»¸å®¹è¨±ç¯„åœï¼Œæ¸›å°‘å·¦å³æ“ºé ­
Y_TOLERANCE = 0         # Y è»¸å®¹è¨±ç¯„åœ (åœæ­¢çš„é–€æª»)
MAX_SPEED = 80           
MIN_SPEED = 15           # ğŸ¯ é—œéµ: å›ºå®šç§»å‹•/è½‰å‘é€Ÿåº¦

CALIBRATION_FACTOR_R = 0.5 #å·¦å³è¼ªèª¤å·®èª¿æ•´

# =========================================================
# III. é¦¬é”æ§åˆ¶å‡½å¼ (åˆ†éšæ®µæ§åˆ¶)
# =========================================================
def init_motor_pins():
    global pwm_L_fwd, pwm_L_bwd, pwm_R_fwd, pwm_R_bwd
    try:
        GPIO.setmode(GPIO.BCM); GPIO.setwarnings(False)
        for pin in [L_FWD_PIN, L_BWD_PIN, R_FWD_PIN, R_BWD_PIN]:
            GPIO.setup(pin, GPIO.OUT)
        pwm_L_fwd = GPIO.PWM(L_FWD_PIN, PWM_FREQUENCY); pwm_L_fwd.start(0)
        pwm_L_bwd = GPIO.PWM(L_BWD_PIN, PWM_FREQUENCY); pwm_L_bwd.start(0)
        pwm_R_fwd = GPIO.PWM(R_FWD_PIN, PWM_FREQUENCY); pwm_R_fwd.start(0)
        pwm_R_bwd = GPIO.PWM(R_BWD_PIN, PWM_FREQUENCY); pwm_R_bwd.start(0)
        print("é¦¬é”æ§åˆ¶è…³ä½åˆå§‹åŒ–å®Œæˆã€‚")
    except Exception as e:
        print(f"GPIO åˆå§‹åŒ–å¤±æ•—: {e}"); cleanup_gpio(); sys.exit(1)

def stop():
    if pwm_L_fwd: pwm_L_fwd.ChangeDutyCycle(0); pwm_L_bwd.ChangeDutyCycle(0)
    if pwm_R_fwd: pwm_R_fwd.ChangeDutyCycle(0); pwm_R_bwd.ChangeDutyCycle(0)

def _set_speed(speed_L, speed_R):
    speed_R = int(speed_R * CALIBRATION_FACTOR_R)
    speed_L = max(0, min(MAX_SPEED_DUTY, speed_L))
    speed_R = max(0, min(MAX_SPEED_DUTY, speed_R))
    return speed_L, speed_R

def move_forward(speed):
    speed_L, speed_R = _set_speed(speed, speed)
    pwm_L_bwd.ChangeDutyCycle(0); pwm_L_fwd.ChangeDutyCycle(speed_L)
    pwm_R_bwd.ChangeDutyCycle(0); pwm_R_fwd.ChangeDutyCycle(speed_R)

def move_backward(speed):
    speed_L, speed_R = _set_speed(speed, speed)
    pwm_L_fwd.ChangeDutyCycle(0); pwm_L_bwd.ChangeDutyCycle(speed_L)
    pwm_R_fwd.ChangeDutyCycle(0); pwm_R_bwd.ChangeDutyCycle(speed_R)

def turn_left(speed): # åŸåœ°å·¦è½‰
    speed_L, speed_R = _set_speed(speed, speed)
    pwm_L_fwd.ChangeDutyCycle(0); pwm_L_bwd.ChangeDutyCycle(speed_L) # å·¦è¼ªå¾Œé€€
    pwm_R_bwd.ChangeDutyCycle(0); pwm_R_fwd.ChangeDutyCycle(speed_R) # å³è¼ªå‰é€²
    
def turn_right(speed): # åŸåœ°å³è½‰
    speed_L, speed_R = _set_speed(speed, speed)
    pwm_L_bwd.ChangeDutyCycle(0); pwm_L_fwd.ChangeDutyCycle(speed_L) # å·¦è¼ªå‰é€²
    pwm_R_fwd.ChangeDutyCycle(0); pwm_R_bwd.ChangeDutyCycle(speed_R) # å³è¼ªå¾Œé€€

def cleanup_gpio():
    try:
        stop()
        if pwm_L_fwd: pwm_L_fwd.stop()
        if pwm_L_bwd: pwm_L_bwd.stop()
        if pwm_R_fwd: pwm_R_fwd.stop()
        if pwm_R_bwd: pwm_R_bwd.stop()
        GPIO.cleanup()
        print("GPIO è³‡æºå·²æ¸…é™¤ã€‚")
    except:
        pass 

# =========================================================
# IV. è¿½è¹¤ä¸»å¾ªç’° 
# =========================================================
def run_tracker():
    init_motor_pins()
    
    picam2 = Picamera2()
    config = picam2.create_preview_configuration(
        main={"size": (FRAME_WIDTH, FRAME_HEIGHT), "format": "BGR888"}
    )
    picam2.configure(config)
    picam2.set_controls({
        'AwbEnable': False,
        'AnalogueGain': 1.0,
        'ColourGains': (1.5, 1.5)
    })
    picam2.start()
    time.sleep(1.0)

    print("--- åˆ†éšæ®µè¿½è¹¤ç¨‹å¼å•Ÿå‹• ---")
    
    try:
        while True:
            frame = picam2.capture_array()
            if FLIP_CODE is not None:
                frame = cv2.flip(frame, FLIP_CODE)

            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            mask = cv2.inRange(hsv, LOWER_COLOR, UPPER_COLOR)
            
            # å½¢æ…‹å­¸æ“ä½œ (é–‹é‹ç®—)
            mask_processed = cv2.erode(mask, None, iterations=2)
            mask_processed = cv2.dilate(mask_processed, None, iterations=2) 

            contours, _ = cv2.findContours(mask_processed.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            ball_found = False
            direction_text = "LOST TARGET"
            dx, dy = 0, 0 
            speed_cmd = 0

            if len(contours) > 0:
                c = max(contours, key=cv2.contourArea)
                ((x, y), radius) = cv2.minEnclosingCircle(c)

                if radius > 2:
                    area = cv2.contourArea(c)
                    if area > 10: 
                        ball_found = True
                        M = cv2.moments(c)
                        if M["m00"] > 0:
                            center_x = int(M["m10"] / M["m00"])
                            center_y = int(M["m01"] / M["m00"]) 
                            
                            dx = center_x - CENTER_X
                            dy = center_y - CENTER_Y
                            
                            fixed_speed = MIN_SPEED 

                            # A. åˆ¤æ–· X è»¸ (åŸåœ°è½‰å‘å„ªå…ˆ)
                            if abs(dx) > X_TOLERANCE:
                                # ğŸ¯ ä¿®æ­£: è½‰å‘é€Ÿåº¦å›ºå®šç‚º MIN_SPEED
                                speed_cmd = fixed_speed
                                
                                if dx < 0:
                                    
                                    turn_left(speed_cmd)
                                    direction_text = f"TRN L {int(speed_cmd)}%"
                                else :
                                    
                                    turn_right(speed_cmd)
                                    direction_text = f"TRN R {int(speed_cmd)}%"
                            
                            # B. X è»¸å°é½Šå¾Œï¼Œåˆ¤æ–· Y è»¸ (å›ºå®šé€Ÿåº¦å‰å¾Œç§»å‹•)
                            else:
                                if abs(dy) > Y_TOLERANCE:
                                    
                                    # ğŸ¯ ä¿®æ­£: å‰å¾Œç§»å‹•é€Ÿåº¦å›ºå®šç‚º MIN_SPEED
                                    speed_cmd = fixed_speed
                                    
                                    # é¡é ­æœä¸Šï¼Œç›®æ¨™ Y=240 é–å®šé‚è¼¯
                                    if dy < 0:
                                        # dy < 0: çƒåœ¨ä¸Šæ–¹ (Y < 240) -> å¤ªè¿‘ï¼Œéœ€è¦å¾Œé€€
                                        move_backward(speed_cmd)
                                        direction_text = f"BCK {int(fixed_speed)}%"
                                    else:
                                        # dy > 0: çƒåœ¨ä¸‹æ–¹ (Y > 240) -> å¤ªé ï¼Œéœ€è¦å‰é€²
                                        move_forward(speed_cmd)
                                        direction_text = f"FWD {int(fixed_speed)}%"
                                else:
                                    # X/Y è»¸éƒ½åœ¨å®¹è¨±ç¯„åœå…§
                                    stop()
                                    direction_text = "TARGET LOCKED"

            if not ball_found:
                stop()
                direction_text = "LOST TARGET"
                
            # 6. è¼¸å‡ºè³‡è¨Šåˆ°çµ‚ç«¯æ©Ÿ 
            print(f"ç‹€æ…‹: {direction_text} | åå·® X: {dx}, Y: {dy} | Speed: {int(speed_cmd)}", end='\r')

    except KeyboardInterrupt:
        print("\nä½¿ç”¨è€…ä¸­æ–·ç¨‹å¼ã€‚")
    except Exception as e:
        print(f"ç¨‹å¼é‹è¡Œä¸­ç™¼ç”ŸéŒ¯èª¤: {e}")
    finally:
        cleanup_gpio()
        picam2.stop()
        picam2.close()
        print("ç¨‹å¼çµæŸã€‚")

if __name__ == '__main__':
    run_tracker()



